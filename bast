using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using Unity.EditorCoroutines.Editor;

public class AsyncBarycentricMeshGenerator : EditorWindow
{
    private Mesh sourceMesh;
    private string newMeshName = "BarycentricMesh";
    private bool preserveUVs = true;
    private bool preserveNormals = true;
    private int stepSize = 1000;

    [MenuItem("Tools/Async Barycentric Mesh Generator")]
    public static void ShowWindow()
    {
        GetWindow<AsyncBarycentricMeshGenerator>("Async Barycentric Mesh Generator");
    }

    void OnGUI()
    {
        GUILayout.Label("Barycentric Mesh Generator", EditorStyles.boldLabel);
        sourceMesh = (Mesh)EditorGUILayout.ObjectField("Source Mesh", sourceMesh, typeof(Mesh), false);
        newMeshName = EditorGUILayout.TextField("New Mesh Name", newMeshName);
        preserveUVs = EditorGUILayout.Toggle("Preserve UVs", preserveUVs);
        preserveNormals = EditorGUILayout.Toggle("Preserve Normals", preserveNormals);

        if (GUILayout.Button("Generate Asynchronously"))
        {
            if (sourceMesh == null)
            {
                EditorUtility.DisplayDialog("Error", "Please assign a source mesh.", "OK");
                return;
            }

            EditorCoroutineUtility.StartCoroutineOwnerless(GenerateAsync());
        }
    }

    System.Collections.IEnumerator GenerateAsync()
    {
        int[] triangles = sourceMesh.triangles;
        Vector3[] vertices = sourceMesh.vertices;
        Vector2[] uvs = preserveUVs && sourceMesh.uv.Length == vertices.Length ? sourceMesh.uv : null;
        Vector3[] normals = preserveNormals && sourceMesh.normals.Length == vertices.Length ? sourceMesh.normals : null;

        List<Vector3> newVerts = new List<Vector3>(triangles.Length);
        List<Color> newColors = new List<Color>(triangles.Length);
        List<Vector2> newUVs = new List<Vector2>(triangles.Length);
        List<Vector3> newNormals = new List<Vector3>(triangles.Length);
        List<int> newIndices = new List<int>(triangles.Length);

        float total = triangles.Length / 3f;

        for (int i = 0; i < triangles.Length; i += 3)
        {
            int triIndex = i / 3;

            for (int j = 0; j < 3; j++)
            {
                int vertexIndex = triangles[i + j];
                newVerts.Add(vertices[vertexIndex]);

                if (uvs != null)
                    newUVs.Add(uvs[vertexIndex]);
                if (normals != null)
                    newNormals.Add(normals[vertexIndex]);

                // Barycentric: red, green, blue per triangle vertex
                newColors.Add(j == 0 ? Color.red :
                              j == 1 ? Color.green :
                                       Color.blue);

                newIndices.Add(newVerts.Count - 1);
            }

            if (i % (stepSize * 3) == 0)
            {
                float progress = i / (float)triangles.Length;
                EditorUtility.DisplayProgressBar("Generating Barycentric Mesh", $"Triangle {triIndex} / {(int)total}", progress);
                yield return null;
            }
        }

        EditorUtility.ClearProgressBar();

        Mesh baryMesh = new Mesh();
        baryMesh.name = newMeshName;
        baryMesh.SetVertices(newVerts);
        baryMesh.SetColors(newColors);
        baryMesh.SetTriangles(newIndices, 0);

        if (uvs != null) baryMesh.SetUVs(0, newUVs);
        if (normals != null) baryMesh.SetNormals(newNormals);

        baryMesh.RecalculateBounds();
        baryMesh.RecalculateTangents();

        string savePath = EditorUtility.SaveFilePanelInProject("Save Barycentric Mesh", newMeshName, "asset", "Choose save location");
        if (!string.IsNullOrEmpty(savePath))
        {
            AssetDatabase.CreateAsset(baryMesh, savePath);
            AssetDatabase.SaveAssets();
            EditorUtility.DisplayDialog("Success", "Mesh saved successfully!", "OK");
        }
    }
}