using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Collections.Generic;

public class AsyncBarycentricMeshGenerator : EditorWindow
{
    private Mesh sourceMesh;
    private string newMeshName = "BarycentricMesh";
    private bool preserveUVs = true;
    private bool preserveNormals = true;

    private int stepSize = 1000; // how many triangles to process per frame

    [MenuItem("Tools/Async Barycentric Mesh Generator")]
    public static void ShowWindow()
    {
        GetWindow<AsyncBarycentricMeshGenerator>("Async Barycentric Mesh Generator");
    }

    void OnGUI()
    {
        GUILayout.Label("Barycentric Mesh Generator", EditorStyles.boldLabel);
        sourceMesh = (Mesh)EditorGUILayout.ObjectField("Source Mesh", sourceMesh, typeof(Mesh), false);
        newMeshName = EditorGUILayout.TextField("New Mesh Name", newMeshName);
        preserveUVs = EditorGUILayout.Toggle("Preserve UVs", preserveUVs);
        preserveNormals = EditorGUILayout.Toggle("Preserve Normals", preserveNormals);

        if (GUILayout.Button("Generate Asynchronously"))
        {
            if (sourceMesh == null)
            {
                EditorUtility.DisplayDialog("Error", "Please assign a source mesh.", "OK");
                return;
            }

            EditorCoroutineUtility.StartCoroutineOwnerless(GenerateAsync());
        }
    }

    IEnumerator GenerateAsync()
    {
        int[] triangles = sourceMesh.triangles;
        Vector3[] verts = sourceMesh.vertices;
        Vector2[] uvs = preserveUVs && sourceMesh.uv.Length == verts.Length ? sourceMesh.uv : null;
        Vector3[] normals = preserveNormals && sourceMesh.normals.Length == verts.Length ? sourceMesh.normals : null;

        List<Vector3> newVerts = new List<Vector3>(triangles.Length);
        List<Vector2> newUVs = new List<Vector2>(triangles.Length);
        List<Vector3> newNormals = new List<Vector3>(triangles.Length);
        List<Color> newColors = new List<Color>(triangles.Length);
        List<int> newIndices = new List<int>(triangles.Length);

        float total = triangles.Length / 3f;

        for (int i = 0; i < triangles.Length; i += 3)
        {
            for (int j = 0; j < 3; j++)
            {
                int oldIndex = triangles[i + j];

                newVerts.Add(verts[oldIndex]);

                if (uvs != null)
                    newUVs.Add(uvs[oldIndex]);

                if (normals != null)
                    newNormals.Add(normals[oldIndex]);

                newColors.Add(j == 0 ? Color.red :
                              j == 1 ? Color.green :
                                       Color.blue);

                newIndices.Add(i + j);
            }

            if (i % (stepSize * 3) == 0)
            {
                float progress = i / (triangles.Length * 1f);
                EditorUtility.DisplayProgressBar("Generating Barycentric Mesh", $"Processing triangle {i / 3} of {triangles.Length / 3}", progress);
                yield return null;
            }
        }

        EditorUtility.ClearProgressBar();

        Mesh result = new Mesh();
        result.name = newMeshName;
        result.SetVertices(newVerts);
        result.SetColors(newColors);
        result.SetTriangles(newIndices, 0);

        if (uvs != null) result.SetUVs(0, newUVs);
        if (normals != null) result.SetNormals(newNormals);

        result.RecalculateBounds();
        result.RecalculateTangents();

        string savePath = EditorUtility.SaveFilePanelInProject("Save Mesh Asset", newMeshName, "asset", "Choose location to save the barycentric mesh");
        if (!string.IsNullOrEmpty(savePath))
        {
            AssetDatabase.CreateAsset(result, savePath);
            AssetDatabase.SaveAssets();
            EditorUtility.DisplayDialog("Success", "Mesh saved to:\n" + savePath, "OK");
        }
    }
}